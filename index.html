<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>hserus 4</title>
<style>
:root{
  --bg:#071827; --card:#0b2430; --muted:#9fb6c7; --accent:#7be3c7; --danger:#ff9a9a;
  --table-bg: #0b2430;
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;background:linear-gradient(#021119,#051521);color:#e6f3f6;padding:16px}
header{display:flex;flex-wrap:wrap;justify-content:space-between;gap:12px;align-items:center}
h1{font-size:18px;margin:0}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
select,button{padding:8px;border-radius:8px;border:1px solid #12333d;background:var(--card);color:inherit}
button{cursor:pointer}
#status{font-size:13px;color:var(--muted)}
main{margin-top:12px}
.tablewrap{overflow:auto;border:1px solid rgba(255,255,255,0.03);border-radius:10px;background:rgba(0,0,0,0.1)}
table{width:100%;border-collapse:collapse;font-size:13px;min-width:1000px}
th,td{text-align:left;padding:10px;border-bottom:1px solid rgba(255,255,255,0.04)}
th{color:var(--muted);font-size:12px;cursor:pointer;white-space:nowrap}
tr.match{background:linear-gradient(90deg, rgba(11,36,48,0.6), rgba(6,28,36,0.4))}
.small{font-size:12px;color:var(--muted)}
.green{color:#7be3c7}
.red{color:#ff9a9a}
.tag{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px}
.tag.up{background:rgba(123,227,199,0.12);color:var(--accent)}
.tag.down{background:rgba(255,154,154,0.08);color:var(--danger)}
.center{ text-align:center }
@media(max-width:800px){ table{min-width:900px} th,td{padding:8px} h1{font-size:16px} }
</style>
</head>
<body>
<header>
  <div>
    <h1>hserus4</h1>
    <div class="small">hserus4</div>
  </div>

  <div class="controls">
    <label class="small">Sort:
      <select id="sortSelect" title="Choose sort column & order">
        <option value="symbol_asc">Symbol ↑</option>
        <option value="symbol_desc">Symbol ↓</option>

        <option value="closePct_desc">Close % ↓</option>
        <option value="closePct_asc">Close % ↑</option>

        <option value="volPct_desc">Vol % ↓</option>
        <option value="volPct_asc">Vol % ↑</option>

        <option value="bbSameDir_desc">BB Same Dir ↓</option>
        <option value="bbSameDir_asc">BB Same Dir ↑</option>

        <option value="distPct_desc">Dist % ↓</option>
        <option value="distPct_asc">Dist % ↑</option>

        <option value="closeVsMiddle_desc">Close vs Mid ↓</option>
        <option value="closeVsMiddle_asc">Close vs Mid ↑</option>

        <option value="bbHighest_desc">BB Highest Change ↓</option>
        <option value="bbHighest_asc">BB Highest Change ↑</option>

        <option value="prevColor_desc">Prev Color ↓</option>
        <option value="prevColor_asc">Prev Color ↑</option>
      </select>
    </label>

    <button id="refreshBtn">Refresh Data</button>
    <div id="status">Idle</div>
  </div>
</header>

<main>
  <div class="tablewrap">
    <table aria-live="polite">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Close %</th>
          <th>Vol % (vs prev)</th>
          <th class="center">BBs same direction?</th>
          <th>Dist from BB (%)</th>
          <th>Close vs Middle</th>
          <th>BB highest rate</th>
          <th>Prev candle</th>
        </tr>
      </thead>
      <tbody id="resultsBody">
        <tr><td colspan="8" class="small">Click <strong>Refresh Data</strong> to start scan.</td></tr>
      </tbody>
    </table>
  </div>
</main>

<script>
/* Config */
const API_KLINES = 'https://fapi.binance.com/fapi/v1/klines';
const API_EXCHANGEINFO = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
const API_TICKER24H = 'https://fapi.binance.com/fapi/v1/ticker/24hr';

const EXCLUDE_TOP20 = [
  'BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','ADAUSDT','DOGEUSDT','TONUSDT','AVAXUSDT','DOTUSDT',
  'TRXUSDT','SHIBUSDT','LINKUSDT','BCHUSDT','NEARUSDT','MATICUSDT','LTCUSDT','ICPUSDT','UNIUSDT','ETCUSDT'
];

const MAX_SYMBOLS = 200;
const KLINES_LIMIT = 25;   // enough to compute SMA20+BB
const SMA_PERIOD = 20;
const PAUSE_MS = 110;      // pause between requests to reduce risk of rate-limits

/* DOM */
const statusEl = document.getElementById('status');
const resultsBody = document.getElementById('resultsBody');
const refreshBtn = document.getElementById('refreshBtn');
const sortSelect = document.getElementById('sortSelect');

let results = [];

/* Helpers */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function pctChange(prev, cur){ if(prev==null||prev===0||cur==null) return NaN; return ((cur - prev) / prev) * 100; }
function toPctText(v){ return (isNaN(v)?'—':(v>=0?'+':'') + v.toFixed(2) + '%'); }
function numOrNaN(x){ return (x==null||isNaN(x)) ? NaN : Number(x); }

/* Bollinger calculator */
function calcBollinger(closes, period=SMA_PERIOD, mult=2){
  const sma = [], upper = [], lower = [];
  for(let i=0;i<closes.length;i++){
    if(i < period-1){ sma.push(null); upper.push(null); lower.push(null); continue; }
    const slice = closes.slice(i-period+1, i+1);
    const mean = slice.reduce((a,b)=>a+b,0)/period;
    const variance = slice.reduce((a,b)=>a+(b-mean)*(b-mean),0)/period;
    const stdev = Math.sqrt(variance);
    sma.push(mean);
    upper.push(mean + mult*stdev);
    lower.push(mean - mult*stdev);
  }
  return { sma, upper, lower };
}

/* Fetch universe: top 200 perpetual USDT (exclude top20) */
async function fetchTop200Symbols(){
  statusEl.textContent = 'Fetching universe...';
  const [infoRes, tickRes] = await Promise.all([fetch(API_EXCHANGEINFO), fetch(API_TICKER24H)]);
  if(!infoRes.ok || !tickRes.ok) throw new Error('Failed to fetch exchange info or tickers');
  const info = await infoRes.json();
  const tick = await tickRes.json();

  const perpSymbols = info.symbols.filter(s => s.contractType==='PERPETUAL' && s.symbol.endsWith('USDT')).map(s=>s.symbol);

  const filteredTick = tick.filter(t => perpSymbols.includes(t.symbol) && !EXCLUDE_TOP20.includes(t.symbol) && t.symbol.endsWith('USDT'));

  const sorted = filteredTick.sort((a,b) => parseFloat(b.quoteVolume || 0) - parseFloat(a.quoteVolume || 0));
  const top = sorted.slice(0, MAX_SYMBOLS).map(x => x.symbol);
  return top;
}

/* Fetch klines (1h) and return array of objects (oldest->newest) */
async function fetchKlines(symbol, limit=KLINES_LIMIT){
  const url = `${API_KLINES}?symbol=${symbol}&interval=1h&limit=${limit}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Klines failed for ' + symbol);
  const raw = await r.json();
  return raw.map(r => ({
    time: r[0],
    open: +r[1],
    high: +r[2],
    low: +r[3],
    close: +r[4],
    volume: +r[5]
  }));
}

/* Evaluate symbol conditions and return object for table if pass */
function evaluateSymbol(symbol, klines){
  if(!klines || klines.length < SMA_PERIOD + 2) return null;
  const n = klines.length;
  const last = klines[n-1];
  const prev = klines[n-2];

  // 1) precheck: current volume > prev volume
  if(!(last.volume > prev.volume)) return null;

  // Extract arrays for BB calculation
  const closes = klines.map(k => k.close);
  const { sma, upper, lower } = calcBollinger(closes);

  // require BBs available for prev and last
  const upper_now = upper[n-1], upper_prev = upper[n-2];
  const lower_now = lower[n-1], lower_prev = lower[n-2];
  const sma_now = sma[n-1], sma_prev = sma[n-2];

  if([upper_now, upper_prev, lower_now, lower_prev, sma_now, sma_prev].some(v => v==null || isNaN(v))) return null;

  // Candle colors
  const currGreen = last.close > last.open;
  const currRed = last.close < last.open;
  // ignore doji for this scanner
  if(!currGreen && !currRed) return null;

  // 2) direction rules:
  // If current green -> require upper_now < upper_prev (upper decreasing)
  // If current red   -> require lower_now > lower_prev (lower increasing)
  if(currGreen && !(upper_now < upper_prev)) return null;
  if(currRed && !(lower_now > lower_prev)) return null;

  // 3) compute BBs same direction?
  const upperDiff = upper_now - upper_prev;
  const lowerDiff = lower_now - lower_prev;
  let bbSameDir = 'No';
  if(upperDiff > 0 && lowerDiff > 0) bbSameDir = 'Up';
  else if(upperDiff < 0 && lowerDiff < 0) bbSameDir = 'Down';
  else bbSameDir = 'No';

  // 4) Distance % from respective band
  let distPct = NaN;
  if(currGreen){
    // how far high is from upper band (positive if above)
    distPct = (last.high - upper_now)/Math.abs(upper_now) * 100;
  } else {
    // how far low is from lower band (positive if below)
    distPct = (lower_now - last.low)/Math.abs(lower_now) * 100;
  }

  // 5) close vs middle
  const closeVsMiddle = last.close > sma_now ? 'Above' : (last.close < sma_now ? 'Below' : 'Equal');

  // 6) which BB line has highest rate of change compared to prev
  // rate = (now - prev)/prev in absolute percentage
  const upperRate = upper_prev !== 0 ? Math.abs((upper_now - upper_prev)/upper_prev * 100) : 0;
  const lowerRate = lower_prev !== 0 ? Math.abs((lower_now - lower_prev)/lower_prev * 100) : 0;
  let bbHighest = 'Equal';
  if(upperRate > lowerRate) bbHighest = 'Upper';
  else if(lowerRate > upperRate) bbHighest = 'Lower';

  // 7) prev candle color
  const prevColor = prev.close > prev.open ? 'Green' : (prev.close < prev.open ? 'Red' : 'Doji');

  // Metrics for display
  const closePct = pctChange(prev.close, last.close);
  const volPct = pctChange(prev.volume, last.volume);

  return {
    symbol,
    closePct: numOrNaN(closePct),
    volPct: numOrNaN(volPct),
    bbSameDir,
    distPct: numOrNaN(distPct),
    closeVsMiddle,
    bbHighest,
    prevColor,
    upperRate,
    lowerRate,
    upperDiff,
    lowerDiff
  };
}

/* Rendering & sorting */
function appendRow(obj){
  const tr = document.createElement('tr');
  tr.className = 'match';
  tr.innerHTML = `
    <td><strong>${obj.symbol}</strong></td>
    <td>${toPctText(obj.closePct)}</td>
    <td>${toPctText(obj.volPct)}</td>
    <td class="center">${obj.bbSameDir === 'No' ? '<span class="tag">No</span>' : `<span class="tag ${obj.bbSameDir==='Up'?'up':'down'}">${obj.bbSameDir}</span>`}</td>
    <td>${isNaN(obj.distPct)?'—':(obj.distPct>=0?'+':'') + obj.distPct.toFixed(2) + '%'}</td>
    <td>${obj.closeVsMiddle}</td>
    <td>${obj.bbHighest} (${obj.upperRate>obj.lowerRate?obj.upperRate.toFixed(2)+'%':obj.lowerRate.toFixed(2)+'%'})</td>
    <td>${obj.prevColor}</td>
  `;
  resultsBody.appendChild(tr);
}

function sortResults(list, sortKey){
  const [key, order] = sortKey.split('_');
  const mul = order === 'asc' ? 1 : -1;
  return list.sort((a,b) => {
    if(key === 'symbol'){
      return mul * a.symbol.localeCompare(b.symbol);
    }
    // Map friendly keys to object fields
    const map = {
      closePct: 'closePct',
      volPct: 'volPct',
      bbSameDir: 'bbSameDir',
      distPct: 'distPct',
      closeVsMiddle: 'closeVsMiddle',
      bbHighest: 'bbHighest',
      prevColor: 'prevColor'
    };
    const field = map[key] || key;
    const va = a[field], vb = b[field];
    // handle NaN / strings
    if(typeof va === 'string' && typeof vb === 'string') return mul * va.localeCompare(vb);
    const na = isNaN(va) ? 1 : 0;
    const nb = isNaN(vb) ? 1 : 0;
    if(na && nb) return 0;
    if(na) return 1 * mul;
    if(nb) return -1 * mul;
    return (va - vb) * mul;
  });
}

function renderTable(){
  const sel = sortSelect.value;
  const sorted = sortResults([...results], sel);
  resultsBody.innerHTML = '';
  if(sorted.length === 0){
    resultsBody.innerHTML = '<tr><td colspan="8" class="small">No matches found.</td></tr>';
    return;
  }
  for(const r of sorted) appendRow(r);
}

/* Main scanning loop */
async function runScan(){
  try{
    results = [];
    resultsBody.innerHTML = '<tr><td colspan="8" class="small">Preparing scan…</td></tr>';
    statusEl.textContent = 'Building universe…';

    const universe = await fetchTop200Symbols();
    statusEl.textContent = `Scanning 0 / ${universe.length}`;

    let i = 0;
    for(const sym of universe){
      i++;
      statusEl.textContent = `Scanning ${i} / ${universe.length}: ${sym}`;
      try {
        // fetch klines first and perform all checks locally
        const kl = await fetchKlines(sym, KLINES_LIMIT);
        const obj = evaluateSymbol(sym, kl);
        if(obj){
          results.push(obj);
          appendRow(obj); // append live so user sees rows as they appear
        }
      } catch(e){
        // ignore fetch errors for a symbol
        // console.warn('symbol error', sym, e);
      }
      await sleep(PAUSE_MS);
    }

    statusEl.textContent = `Scan complete — found ${results.length} matches.`;
    renderTable();
  } catch(err){
    console.error(err);
    statusEl.textContent = 'Error: ' + (err.message || err);
    resultsBody.innerHTML = '<tr><td colspan="8" class="small">Error during scan. See console.</td></tr>';
  }
}

/* Wiring */
refreshBtn.addEventListener('click', ()=>{
  refreshBtn.disabled = true;
  resultsBody.innerHTML = '<tr><td colspan="8" class="small">Starting scan…</td></tr>';
  runScan().finally(()=> refreshBtn.disabled = false);
});

sortSelect.addEventListener('change', renderTable);

// Auto-run on load
window.addEventListener('load', () => { refreshBtn.click(); });

</script>
</body>
</html>
