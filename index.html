<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>hserus 4</title>
  <style>
    :root{--bg:#071827;--card:#0b2430;--muted:#9fb6c7;--accent:#7be3c7;--danger:#ff9a9a}
    body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(#021119,#051521);color:#e6f3f6;padding:14px}
    header{display:flex;flex-wrap:wrap;justify-content:space-between;gap:12px;align-items:center}
    h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    select,button{padding:8px;border-radius:8px;border:1px solid #12333d;background:var(--card);color:inherit}
    button{cursor:pointer}
    #status{font-size:13px;color:var(--muted)}
    main{margin-top:12px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{text-align:left;padding:10px;border-bottom:1px solid rgba(255,255,255,0.04)}
    th{color:var(--muted);font-size:12px}
    tr.match{background:linear-gradient(90deg, rgba(11,36,48,0.6), rgba(6,28,36,0.4))}
    .small{font-size:12px;color:var(--muted)}
    .green{color:#7be3c7}
    .red{color:#ff9a9a}
    @media(max-width:720px){ th,td{padding:8px;font-size:12px} h1{font-size:16px} }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>hserus 4</h1>
      <div class="small">hserus 4</div>
    </div>

    <div class="controls">
      <label class="small">Sort:
        <select id="sortSelect" title="Choose sort column & order">
          <option value="shortDiff_desc">shortDiff ↓ (default)</option>
          <option value="shortDiff_asc">shortDiff ↑</option>

          <option value="prevClosePct_desc">Prev Close % ↓</option>
          <option value="prevClosePct_asc">Prev Close % ↑</option>

          <option value="currClosePct_desc">Curr Close % ↓</option>
          <option value="currClosePct_asc">Curr Close % ↑</option>

          <option value="currVolPct_desc">Curr Vol % ↓</option>
          <option value="currVolPct_asc">Curr Vol % ↑</option>

          <option value="prevVolPct_desc">Prev Vol % ↓</option>
          <option value="prevVolPct_asc">Prev Vol % ↑</option>

          <option value="currShortPct_desc">Curr Short % ↓</option>
          <option value="currShortPct_asc">Curr Short % ↑</option>

          <option value="prevShortPct_desc">Prev Short % ↓</option>
          <option value="prevShortPct_asc">Prev Short % ↑</option>
        </select>
      </label>

      <button id="refreshBtn">Refresh Data</button>
      <div id="status">Idle</div>
    </div>
  </header>

  <main>
    <table aria-live="polite">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Prev Close %</th>
          <th>Curr Close %</th>
          <th>Curr Vol %</th>
          <th>Prev Vol %</th>
          <th>Curr Short %</th>
          <th>Prev Short %</th>
          <th>shortDiff</th>
        </tr>
      </thead>
      <tbody id="resultsBody">
        <tr><td colspan="8" class="small">Click <strong>Refresh Data</strong> or reload page to start scan</td></tr>
      </tbody>
    </table>
  </main>

<script>
/* F */

/* ---------- Config ---------- */
const LIMIT = 10;           // candles to fetch per symbol (we need at least 4; 40 is safe)
const INTERVAL = '1h';
const MAX_SYMBOLS = 200;    // top N symbols to scan
const SHORT_API_LIMIT = 5;  // number of shortAccount entries to fetch (we need at least 3)
const EXCLUDE = ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TONUSDT","AVAXUSDT","DOTUSDT","TRXUSDT","SHIBUSDT","LINKUSDT","NEARUSDT","MATICUSDT","LTCUSDT","UNIUSDT","BCHUSDT","ICPUSDT","LEOUSDT"];

const statusEl = document.getElementById('status');
const resultsBody = document.getElementById('resultsBody');
const refreshBtn = document.getElementById('refreshBtn');
const sortSelect = document.getElementById('sortSelect');

let results = []; // live matches

/* ---------- Network helpers ---------- */
async function fetchPerpetualSymbols() {
  const url = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
  const r = await fetch(url);
  if (!r.ok) throw new Error('exchangeInfo failed');
  const data = await r.json();
  return data.symbols
    .filter(s => s.contractType === 'PERPETUAL' && s.symbol.endsWith('USDT') && !EXCLUDE.includes(s.symbol))
    .map(s => s.symbol);
}

async function fetchTopSymbols(limit = MAX_SYMBOLS) {
  const url = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
  const [tickRes, perpSymbols] = await Promise.all([fetch(url), fetchPerpetualSymbols()]);
  if (!tickRes.ok) throw new Error('ticker24hr failed');
  const tick = await tickRes.json();
  return tick
    .filter(t => t.symbol.endsWith('USDT') && perpSymbols.includes(t.symbol))
    .sort((a,b) => Math.abs(parseFloat(b.priceChangePercent || 0)) - Math.abs(parseFloat(a.priceChangePercent || 0)))
    .slice(0, limit)
    .map(t => t.symbol);
}

/* fetch klines (futures) */
async function fetchKlines(symbol, limit = LIMIT) {
  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${limit}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('klines failed for ' + symbol + ' : ' + res.status);
  const raw = await res.json();
  return raw.map(r => ({ open:+r[1], high:+r[2], low:+r[3], close:+r[4], volume:+r[5] }));
}

/* fetch shortAccount series for a futures symbol (period=1h) */
async function fetchShortAccounts(symbol, limit = SHORT_API_LIMIT) {
  // endpoint: /futures/data/topLongShortAccountRatio
  const url = `https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${symbol}&period=1h&limit=${limit}`;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('longAccount fetch failed: ' + res.status);
    const arr = await res.json();
    // arr ordered oldest->newest? Binance returns newest-last typically in ascending timestamp; to be safe map to numeric
    // pick the last `limit` and map shortAccount to float
    return arr.map(x => (x && x.longAccount != null) ? parseFloat(x.longAccount) : null);
  } catch (e) {
    console.warn('fetchLongAccounts error', symbol, e.message || e);
    return Array(limit).fill(null);
  }
}

/* ---------- Utility helpers ---------- */
function pctChange(prev, cur) {
  if (prev === 0 || prev === null || prev === undefined) return NaN;
  return ((cur - prev) / prev) * 100;
}
function isDoji(candle) { return candle.close === candle.open; }

/* Sorting utility */
function sortResults(list, sortKey) {
  const [key, order] = sortKey.split('_'); // e.g. shortDiff_desc
  const multiplier = (order === 'asc') ? 1 : -1;
  return list.sort((a,b) => {
    const va = (key in a) ? a[key] : NaN;
    const vb = (key in b) ? b[key] : NaN;
    if (isNaN(va) && isNaN(vb)) return 0;
    if (isNaN(va)) return 1 * multiplier;
    if (isNaN(vb)) return -1 * multiplier;
    return (va - vb) * multiplier;
  });
}

/* ---------- Rendering ---------- */
function formatPct(x, digits=2) {
  if (x === null || x === undefined || isNaN(x)) return '—';
  return x.toFixed(digits) + '%';
}

function appendRow(obj) {
  const currentSort = sortSelect.value;
  if (currentSort === 'shortDiff_desc') {
    const tr = document.createElement('tr');
    tr.className = 'match';
    tr.innerHTML = `
      <td><strong>${obj.symbol}</strong></td>
      <td>${formatPct(obj.prevClosePct)}</td>
      <td>${formatPct(obj.currClosePct)}</td>
      <td>${formatPct(obj.currVolPct)}</td>
      <td>${formatPct(obj.prevVolPct)}</td>
      <td>${formatPct(obj.currShortPct)}</td>
      <td>${formatPct(obj.prevShortPct)}</td>
      <td class="${obj.shortDiff>=0 ? 'green' : 'red'}">${(isNaN(obj.shortDiff) ? '—' : obj.shortDiff.toFixed(6))}</td>
    `;
    resultsBody.appendChild(tr);
  } else {
    renderTable();
  }
}

function renderTable() {
  const sel = sortSelect.value;
  const cloned = [...results];
  const sorted = sortResults(cloned, sel);
  resultsBody.innerHTML = '';
  if (sorted.length === 0) {
    resultsBody.innerHTML = '<tr><td colspan="8" class="small">No matches found.</td></tr>';
    return;
  }
  for (const r of sorted) {
    const tr = document.createElement('tr');
    tr.className = 'match';
    tr.innerHTML = `
      <td><strong>${r.symbol}</strong></td>
      <td>${formatPct(r.prevClosePct)}</td>
      <td>${formatPct(r.currClosePct)}</td>
      <td>${formatPct(r.currVolPct)}</td>
      <td>${formatPct(r.prevVolPct)}</td>
      <td>${formatPct(r.currShortPct)}</td>
      <td>${formatPct(r.prevShortPct)}</td>
      <td class="${r.shortDiff>=0 ? 'green' : 'red'}">${(isNaN(r.shortDiff) ? '—' : r.shortDiff.toFixed(6))}</td>
    `;
    resultsBody.appendChild(tr);
  }
}

/* ---------- Core matching logic ---------- */
/* indicator retrieval wrapper - makes swapping easy if you want later */
async function getShortAccountsForSymbol(symbol) {
  // returns array of floats (length = SHORT_API_LIMIT), order preserved from response
  // We expect at minimum 3 meaningful entries; if not available, elements may be null.
  return await fetchShortAccounts(symbol, SHORT_API_LIMIT);
}

function checkConditionsAndBuildObject(symbol, klines, shortArr) {
  const n = klines.length;
  if (n < 4) return null; // need at least 4 candles to compute prev/cur % changes

  // ensure we have at least 3 shortAccount values (we'll use last 3)
  if (!shortArr || shortArr.length < 3) return null;

  // take last 3 short entries
  const lastShort = shortArr[shortArr.length - 1];
  const prevShort = shortArr[shortArr.length - 2];
  const prevPrevShort = shortArr[shortArr.length - 3];

  if (lastShort === null || prevShort === null || prevPrevShort === null) return null;

  // closes & volumes arrays (oldest->newest)
  const closes = klines.map(k => k.close);
  const vols = klines.map(k => k.volume);

  const lastClose = closes[n-1], prevClose = closes[n-2], prev2Close = closes[n-3];
  const lastVol = vols[n-1], prevVol = vols[n-2], prev2Vol = vols[n-3];

  // 1) current volume > prev volume
  if (!(lastVol > prevVol)) return null;

  // 2) direction vs shortAccount:
  const isGreen = lastClose > prevClose;
  const isRed = lastClose < prevClose;
  if (!(isGreen || isRed)) return null; // ignore doji

  if (isRed && !(lastShort > prevShort)) return null;    // shorts must be increasing
  if (isGreen && !(lastShort < prevShort)) return null;  // shorts must be decreasing

  // 3) magnitude: abs(curr short % change) >= 2 * abs(prev short % change)
  const currShortPct = pctChange(prevShort, lastShort);
  const prevShortPct = pctChange(prevPrevShort, prevShort);
  if (!(Math.abs(currShortPct) >= 2 * Math.abs(prevShortPct))) return null;

  // compute other output columns:
  const currClosePct = pctChange(prevClose, lastClose);
  const prevClosePct = pctChange(prev2Close, prevClose);
  const currVolPct = pctChange(prevVol, lastVol);
  const prevVolPct = pctChange(prev2Vol, prevVol);

  const shortDiff = lastShort - prevShort;

  return {
    symbol,
    prevClosePct,
    currClosePct,
    currVolPct,
    prevVolPct,
    currShortPct,
    prevShortPct,
    shortDiff
  };
}

/* ---------- Main scan loop ---------- */
async function runScan() {
  try {
    results = [];
    resultsBody.innerHTML = '<tr><td colspan="8" class="small">Preparing scan...</td></tr>';
    statusEl.textContent = 'Fetching symbol list...';

    const symbols = await fetchTopSymbols(MAX_SYMBOLS);
    statusEl.textContent = `Scanning 0 / ${symbols.length}`;

    let i = 0;
    for (const sym of symbols) {
      i++;
      statusEl.textContent = `Scanning ${i} / ${symbols.length}: ${sym}`;
      try {
        const klines = await fetchKlines(sym);
        // fetch shortAccount series for symbol
        const shortArr = await getShortAccountsForSymbol(sym); // array of shortAccount floats
        const matchObj = checkConditionsAndBuildObject(sym, klines, shortArr);
        if (matchObj) {
          results.push(matchObj);
          appendRow(matchObj); // live append
        }
      } catch (e) {
        // ignore symbol-level errors and continue
        //console.warn('err', sym, e);
      }
      // small delay so UI can update and to be polite
      await sleep(120);
    }

    statusEl.textContent = `Scan complete — found ${results.length} matches.`;
    // final render (sorted according to dropdown)
    renderTable();
  } catch (err) {
    console.error(err);
    statusEl.textContent = 'Error: ' + (err.message || err);
  }
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

/* ---------- Wiring ---------- */
refreshBtn.addEventListener('click', () => {
  refreshBtn.disabled = true;
  resultsBody.innerHTML = '<tr><td colspan="8" class="small">Starting scan... (this may take 20-60s)</td></tr>';
  runScan().finally(() => { refreshBtn.disabled = false; });
});

sortSelect.addEventListener('change', () => { renderTable(); });

/* Auto-run on page load (so page refresh triggers a scan). If you don't want auto-run, comment this line out. */
window.addEventListener('load', () => {
  // start a scan automatically on page load
  refreshBtn.click();
});
</script>
</body>
</html>
